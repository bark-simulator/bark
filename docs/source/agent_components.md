Models
================================
Each agent contains individual instances of the following model-components:
1. **Behavior-Model** <br />
  Creates a sequence of desired states the agent should follow.
2. **Execution-Model** <br />
  Validates the state-sequence generated by the behavior-model. For example, in the case of a vehicle, it might check the dynamical feasibility. 
3. **Dynamic-Model** <br />
  Can be used by all models in order to plan and to validate in a dynamically feasible way.


## Behavior-Model
The `BehaviorModel` is a base-class from which different behavior-models are derived. The `Plan`-function plans a behavior for an agent over a given time-horizon (current time + `delta_time`).

```cpp
class BehaviorModel : public modules::commons::BaseType {
    virtual Trajectory Plan(world::objects::AgentId agent_id,
                            float delta_time,
                            const world::ObservedWorld& observed_world) = 0;
}
```
The behavior-model has only access to the observed world as described [here](world.md).

### BehaviorConstantVelocity
The constant-velocity model interpolates an agent along a set route with constant velocity.

```cpp
class BehaviorConstantVelocity : public BehaviorModel {
 public:
  explicit BehaviorConstantVelocity(const commons::ParamsPtr& params) :
    BehaviorModel(params) {}

  virtual ~BehaviorConstantVelocity() {}

  Trajectory Plan(AgentId agent_id,
                 float delta_time,
                 const ObservedWorld& observed_world);

  virtual BehaviorModel *Clone() const;
};
```

## Execution Model
The execution-model validates or makes the generated behavior dynamically feasible. However, it is also possible to skip this layer using the `ExecutionModelInterpolate` model.

```cpp
class ExecutionModel : public commons::BaseType {
 public:
  explicit ExecutionModel(const modules::commons::ParamsPtr params) :
    BaseType(params),
    last_trajectory_() {}

  virtual ~ExecutionModel() {}

  Trajectory GetLastTrajectory() { return last_trajectory_; }

  void SetLastTrajectory(const Trajectory& trajectory) {
    last_trajectory_ = trajectory;
  }

  virtual Trajectory Execute(const float& new_world_time,
                             const Trajectory& trajectory,
                             const DynamicModelPtr dynamic_model,
                             const State current_state) = 0;

 private:
  Trajectory last_trajectory_;
};
```

### ExecutionModelInterpolate
This model does not modify the behavior generated by the `BehaviorModel`. This can be useful for applications, such as reinforcement learning.

### ExecutionModelMpc
The Model Predictive Control (MPC) optimizes the original behavior producing a dynamically feasible motion. 
The MPC is implemented utilizing the [Ceres-solver](http://ceres-solver.org/) library.

```cpp
class ExecutionModelMpc : public ExecutionModel {
 public:
  explicit ExecutionModelMpc(const commons::ParamsPtr& params);

  ~ExecutionModelMpc() {}

  Matrix<double, Dynamic, Dynamic> get_last_weights() {
    return last_weights_;
  }

  Trajectory get_last_desired_states() { return last_desired_states_; }

  void set_last_weights(const Matrix<double, Dynamic, Dynamic> &weights) {
    last_weights_ = weights;
  }

  void set_last_desired_states(const Trajectory &desired_states) {
    last_desired_states_ = desired_states;
  }

  virtual Trajectory Execute(const float &new_world_time,
                             const Trajectory &trajectory,
                             const DynamicModelPtr dynamic_model,
                             const State current_state);

  Trajectory Optimize(std::vector<double*> parameter_block,
                      const Trajectory &discrete_behavior,
                      const Matrix<double, Dynamic, Dynamic> weights_desired_states);

 private:
  execution::OptimizationSettings optimization_settings_;
  Matrix<double, Dynamic, Dynamic> last_weights_;
  Trajectory last_desired_states_;
};
```


## Dynamic Model
The `DynamicModel`-class implements the base-class from which dynamic models are derived.
The `StateSpaceModel`-function allows for a flexible implementation of a variety of linear and non-linear dynamic state-space models.

```cpp
class DynamicModel {
 public:
  DynamicModel() {}

  virtual State StateSpaceModel(const State &x, const Input &u) const = 0;

  virtual DynamicModel *Clone() const = 0;
};

```

### SingleTrackModel
The `SingleTrackModel`-class represents a simplified vehicle-model.

```cpp
  public:
    SingleTrackModel() {}
    virtual ~SingleTrackModel() {}

    State StateSpaceModel(const State &x, const Input &u) const;
    DynamicModel *Clone() const {
      return new SingleTrackModel(*this);
    }
```

The single-track model uses the following equations:

```eval_rst
  :math:`L_f : \textrm{wheel-base}` 
```

The following equations present the model 
```eval_rst
  .. math:: 
    \textrm{input vector: } \mathbf{u} = \left(
    \begin{array}{c}
    u_0\\
    u_1\\
    \end{array}
    \right) 
    \begin{matrix}
    \textrm{: acceleration}\\
    \textrm{: steering angle}\\
    \end{matrix}
  
  .. math::
    \textrm{state vector: } \mathbf{x} = \left(
    \begin{array}{c}
    t\\
    x\\
    y\\
    \theta\\
    v\\
    \end{array}
    \right)
    \begin{matrix}
    \textrm{: time}\\
    \textrm{: x-position}\\
    \textrm{: y-position}\\
    \textrm{: vehicle-angle}\\
    \textrm{: velocity}\\
    \end{matrix}

  .. math::
    \mathbf{\dot{x}} = f(\mathbf{x},\mathbf{u}) = \left(
    \begin{array}{c}
    1\\
    v \cdot cos(\theta)\\
    v \cdot sin(\theta)\\
    v \cdot \frac{tan(u_1)}{L_f}\\
    u_0\\
    \end{array}
    \right)

```

