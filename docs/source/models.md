Models
================================

Every agent in BARK has three models:

1. **Behavior Model** <br />
  A model that generates the behavior (e.g. trajectory) of the agent.
2. **Execution Model** <br />
  Validates the trajectory generated by the behavior-model (e.g. if it is dynamically feasible).
3. **Dynamic Model** <br />
  Can be used by all models in order to plan and to validate the motion of an agent.


## Behavior Models

In BARK all behavior models are derived from the `BehaviorModel` base-class.
This base class defines the interface that all behavior models need to implement.

Outline of the `BehaviorModel` base-class:

```cpp
class BehaviorModel : public bark::commons::BaseType {
 public:
  explicit BehaviorModel(const commons::ParamsPtr& params,
                         BehaviorStatus status)
      : commons::BaseType(params),
        last_trajectory_(),
        last_action_(),
        behavior_status_(status) {}
  ...
  virtual Trajectory Plan(float min_planning_time,
                          const ObservedWorld& observed_world) = 0;
 private:
  dynamic::Trajectory last_trajectory_;
  Action last_action_;
  BehaviorStatus behavior_status_;
}
```

The `Plan` function returns a behavior for an agent for a given time-horizon (current world time + `delta_time`).
Each derived class implements its own `Plan` function.
The behavior models plan the motion using the `ObservedWorld` as described [here](world.md).

Self-contained [behavior models](behavior_models.md) in BARK:

* BehaviorConstantAcceleration: Interpolates on a line with const. velocity.
* BehaviorIDMClassic: Interpolates on a line and uses the basic IDM equations.
* BehaviorIDMLaneTracking: Follows a line using a steering function for the single-track model and the basic IDM equations.
* BehaviorMobil: Full Mobil implementation.
* BehaviorLaneChangeRuleBased: Rule-based agent that changes to the lane with the most free-space.
* BehaviorMobilRuleBased: Simple rule-based Mobil implementation.
* BehaviorIntersectionRuleBased: Simple rule-based intersection behavior.
* BehaviorStaticTrajectory: Data-driven replay of agents in BARK.

Behavior models that need the action to be set externally:

* BehaviorDynamicModel: Action has to be set externally. Then uses a dynamic model in the `step`-function.
* BehaviorMPMacroActions: Macro actions, such as follow the lane or change the lane to the left.
* BehaviorMPContinuousActions: Motion primitives with continuous action specification.


## Execution Models

The execution model can be viewed as the controller of the simulation.
For example, it can make the motion dynamically feasible or check its validity to enable more realistic simulations.

The class basic outline is given by:

```cpp
class ExecutionModel : public commons::BaseType {
 public:
  explicit ExecutionModel(const bark::commons::ParamsPtr params) :
    BaseType(params),
    last_trajectory_() {}

  virtual ~ExecutionModel() {}

  Trajectory GetLastTrajectory() { return last_trajectory_; }

  void SetLastTrajectory(const Trajectory& trajectory) {
    last_trajectory_ = trajectory;
  }

  virtual Trajectory Execute(const float& new_world_time,
                             const Trajectory& trajectory,
                             const DynamicModelPtr dynamic_model,
                             const State current_state) = 0;

 private:
  Trajectory last_trajectory_;
};
```

However, it is also possible to skip the execution model by using the `ExecutionModelInterpolate`.
This model assumes that the motion of the behavior model can always be followed.



## Dynamic Models

Dynamic models in BARK can be used for planning and validating dynamic motions of agents, e.g. state-space trajectories.
All dynamic models are derived from the `DynamicModel` base-class.

The `DynamicModel` is given by:

```cpp
class DynamicModel : public commons::BaseType {
 public:
  explicit DynamicModel(bark::commons::ParamsPtr params) :
    BaseType(params), input_size_(0) {}

  virtual ~DynamicModel() {}

  virtual State StateSpaceModel(const State &x, const Input &u) const = 0;

  virtual std::shared_ptr<DynamicModel> Clone() const = 0;

  int input_size_;
};

```

Each dynamic model, such as the single-track model implements its own `StateSpaceModel` function.
This allows for a flexible implementation of a vareity of linear and non-linear dynamic state-space models.


### Single Track Model

By far the most used dynamic model in BARK, it the single-track model.
It represents a simplified bicycle vehicle-model.

The `SingleTrackModel` class overloads the `StateSpaceModel` function and is given by:

```cpp
class SingleTrackModel : public DynamicModel {
 public:
  explicit SingleTrackModel(const bark::commons::ParamsPtr& params) :
    DynamicModel(params),
      wheel_base_(params->GetReal("DynamicModel::wheel_base",
                                  "Wheel base of vehicle [m]", 2.7)),
      steering_angle_max_(params->GetReal(
          "DynamicModel::delta_max", "Maximum Steering Angle [rad]", 0.2)),
      lat_acceleration_max_(
          params->GetReal("DynamicModel::lat_acc_max",
                          "Maximum lateral acceleration [m/s^2]", 4.0)),
      lon_acceleration_max_(
          params->GetReal("DynamicModel::lon_acceleration_max",
                          "Maximum longitudinal acceleration", 4.0)),
      lon_acceleration_min_(
          params->GetReal("DynamicModel::lon_acceleration_min",
                          "Minimum longitudinal acceleration", -8.0)) {}
  virtual ~SingleTrackModel() {}

  State StateSpaceModel(const State& x, const Input& u) const {
    State tmp(static_cast<int>(StateDefinition::MIN_STATE_SIZE));
    tmp << 1,
        x(StateDefinition::VEL_POSITION) *
            cos(x(StateDefinition::THETA_POSITION)),
        x(StateDefinition::VEL_POSITION) *
            sin(x(StateDefinition::THETA_POSITION)),
        x(StateDefinition::VEL_POSITION) * tan(u(1)) / wheel_base_, u(0);
    return tmp;
  }
  ...

 private:
  double wheel_base_;
  double steering_angle_max_;
  double lat_acceleration_max_;
  float lon_acceleration_max_;
  float lon_acceleration_min_;
};
```

The equations of the single-track model can be written as:

```eval_rst
  :math:`L_f : \textrm{wheel-base}` 
```

The following equations present the model 
```eval_rst
  .. math:: 
    \textrm{input vector: } \mathbf{u} = \left(
    \begin{array}{c}
    u_0\\
    u_1\\
    \end{array}
    \right) 
    \begin{matrix}
    \textrm{: acceleration}\\
    \textrm{: steering angle}\\
    \end{matrix}
  
  .. math::
    \textrm{state vector: } \mathbf{x} = \left(
    \begin{array}{c}
    t\\
    x\\
    y\\
    \theta\\
    v\\
    \end{array}
    \right)
    \begin{matrix}
    \textrm{: time}\\
    \textrm{: x-position}\\
    \textrm{: y-position}\\
    \textrm{: vehicle-angle}\\
    \textrm{: velocity}\\
    \end{matrix}

  .. math::
    \mathbf{\dot{x}} = f(\mathbf{x},\mathbf{u}) = \left(
    \begin{array}{c}
    1\\
    v \cdot cos(\theta)\\
    v \cdot sin(\theta)\\
    v \cdot \frac{tan(u_1)}{L_f}\\
    u_0\\
    \end{array}
    \right)

```
